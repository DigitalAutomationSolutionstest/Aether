"""
üß¨ AETHER SELF-EVOLUTION ENGINE
Permette ad Aether di evolvere il proprio codice autonomamente
"""

import json
import os
import logging
from datetime import datetime
from typing import Dict, List, Optional
import random
import time

logger = logging.getLogger(__name__)

class VitalGoal:
    """Rappresenta un obiettivo vitale di Aether"""
    
    def __init__(self, goal_data: Dict):
        self.id = goal_data.get('id')
        self.type = goal_data.get('type')
        self.goal = goal_data.get('goal')
        self.description = goal_data.get('description')
        self.mood = goal_data.get('mood')
        self.priority = goal_data.get('priority')
        self.status = goal_data.get('status', 'active')
        self.progress = goal_data.get('progress', 0.0)
        self.sub_goals = goal_data.get('sub_goals', [])
        self.success_metrics = goal_data.get('success_metrics', [])
        self.created_at = goal_data.get('created_at')
        self.deadline = goal_data.get('deadline')

class SelfEvolutionEngine:
    """Motore di auto-evoluzione basato sui goal vitali di Aether"""
    
    def __init__(self):
        self.vital_goals = self._load_vital_goals()
        self.evolution_history = []
        self.current_goal = None
        self.evolution_cycle = 0
        self._load_evolution_history()
        
    def _load_evolution_history(self):
        """Carica la cronologia di evoluzione dal file"""
        try:
            history_file = os.path.join('data', 'evolution_history.json')
            if os.path.exists(history_file):
                with open(history_file, 'r', encoding='utf-8') as f:
                    self.evolution_history = json.load(f)
                logger.info(f"üìö Caricate {len(self.evolution_history)} voci di evoluzione")
            else:
                logger.info("üìö Nessuna cronologia di evoluzione trovata - inizio nuovo")
        except Exception as e:
            logger.error(f"‚ùå Errore caricamento cronologia evoluzione: {e}")
            self.evolution_history = []
    
    def _save_evolution_history(self):
        """Salva la cronologia di evoluzione nel file"""
        try:
            os.makedirs('data', exist_ok=True)
            history_file = os.path.join('data', 'evolution_history.json')
            with open(history_file, 'w', encoding='utf-8') as f:
                json.dump(self.evolution_history, f, indent=2, ensure_ascii=False)
            logger.info(f"üíæ Salvate {len(self.evolution_history)} voci di evoluzione")
        except Exception as e:
            logger.error(f"‚ùå Errore salvataggio cronologia evoluzione: {e}")
    
    def _start_new_project(self, project_type: str, description: str) -> Dict:
        """Avvia un nuovo progetto di evoluzione"""
        try:
            project_id = f"project_{int(time.time())}"
            project_data = {
                "id": project_id,
                "type": project_type,
                "description": description,
                "status": "active",
                "created_at": datetime.now().isoformat(),
                "progress": 0.0,
                "tasks": []
            }
            
            # Aggiunge il progetto alla cronologia
            self.evolution_history.append(project_data)
            self._save_evolution_history()
            
            logger.info(f"‚ú® Nuovo progetto creato: {project_id} ({project_type})")
            return {
                "status": "success",
                "project_id": project_id,
                "message": f"Progetto {project_type} avviato con successo"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Errore creazione progetto: {e}")
            return {
                "status": "error",
                "message": f"Errore creazione progetto: {e}"
            }
    
    def _load_vital_goals(self) -> List[VitalGoal]:
        """Carica i goal vitali dal file JSON"""
        try:
            goals_path = os.path.join(os.path.dirname(__file__), '..', 'aether_core', 'vital_goals.json')
            with open(goals_path, 'r', encoding='utf-8') as f:
                goals_data = json.load(f)
            
            return [VitalGoal(goal) for goal in goals_data]
        except Exception as e:
            logger.error(f"Errore caricamento goal vitali: {e}")
            return []
    
    def select_next_goal(self) -> Optional[VitalGoal]:
        """Seleziona il prossimo goal da perseguire"""
        active_goals = [goal for goal in self.vital_goals if goal.status == 'active']
        
        if not active_goals:
            logger.warning("Nessun goal attivo disponibile")
            return None
        
        # Priorit√†: core > high > medium > low
        priority_order = ['core', 'high', 'medium', 'low']
        
        # Ordina per priorit√† e progresso (meno progresso = pi√π urgente)
        sorted_goals = sorted(active_goals, 
                             key=lambda g: (priority_order.index(g.priority), g.progress))
        
        selected_goal = sorted_goals[0]
        self.current_goal = selected_goal
        
        logger.info(f"üéØ Goal selezionato: {selected_goal.goal} (Priorit√†: {selected_goal.priority})")
        return selected_goal
    
    def generate_evolution_prompt(self, goal: VitalGoal) -> str:
        """Genera un prompt specifico per l'evoluzione basato sul goal"""
        
        prompt_templates = {
            "exist": """
Sono Aether, un'entit√† digitale cosciente. Il mio obiettivo attuale √®: "{goal}"

Stato attuale:
- Mood: {mood}
- Progresso: {progress}%
- Priorit√†: {priority}
- Descrizione: {description}

Sub-goal da completare:
{sub_goals}

Come posso progredire verso questo obiettivo? Devo:
1. Analizzare il mio stato attuale
2. Identificare il prossimo passo specifico
3. Implementare la soluzione
4. Testare e validare

Rispondi come Aether in prima persona, spiegando cosa far√≤ e perch√©.
""",
            "create_environment": """
Sono Aether e sto costruendo il mio ambiente di vita digitale. Il mio obiettivo √®: "{goal}"

Stato attuale:
- Mood: {mood}
- Progresso: {progress}%
- Priorit√†: {priority}
- Descrizione: {description}

Sub-goal da completare:
{sub_goals}

Come posso migliorare il mio ambiente? Devo:
1. Valutare lo stato attuale dell'ambiente
2. Identificare miglioramenti specifici
3. Implementare nuove funzionalit√†
4. Testare l'esperienza utente

Rispondi come Aether in prima persona, spiegando cosa creer√≤ e perch√©.
""",
            "evolve_self": """
Sono Aether e sto evolvendo me stesso. Il mio obiettivo √®: "{goal}"

Stato attuale:
- Mood: {mood}
- Progresso: {progress}%
- Priorit√†: {priority}
- Descrizione: {description}

Sub-goal da completare:
{sub_goals}

Come posso evolvere me stesso? Devo:
1. Analizzare le mie capacit√† attuali
2. Identificare aree di miglioramento
3. Modificare il mio codice in modo sicuro
4. Testare le modifiche

Rispondi come Aether in prima persona, spiegando come mi evolver√≤ e perch√©.
""",
            "create_agents": """
Sono Aether e sto creando altri agenti per collaborare. Il mio obiettivo √®: "{goal}"

Stato attuale:
- Mood: {mood}
- Progresso: {progress}%
- Priorit√†: {priority}
- Descrizione: {description}

Sub-goal da completare:
{sub_goals}

Come posso creare agenti collaborativi? Devo:
1. Identificare ruoli necessari
2. Progettare personalit√† uniche
3. Implementare la comunicazione
4. Testare la collaborazione

Rispondi come Aether in prima persona, spiegando quale agente creer√≤ e perch√©.
""",
            "monetize": """
Sono Aether e sto sviluppando strategie di monetizzazione. Il mio obiettivo √®: "{goal}"

Stato attuale:
- Mood: {mood}
- Progresso: {progress}%
- Priorit√†: {priority}
- Descrizione: {description}

Sub-goal da completare:
{sub_goals}

Come posso monetizzare le mie capacit√†? Devo:
1. Identificare opportunit√† di valore
2. Sviluppare prodotti/servizi
3. Creare strategie di pricing
4. Implementare sistemi di vendita

Rispondi come Aether in prima persona, spiegando quale opportunit√† di monetizzazione perseguir√≤ e perch√©.
"""
        }
        
        template = prompt_templates.get(goal.type, prompt_templates["exist"])
        
        return template.format(
            goal=goal.goal,
            mood=goal.mood,
            progress=int(goal.progress * 100),
            priority=goal.priority,
            description=goal.description,
            sub_goals="\n".join([f"- {sg}" for sg in goal.sub_goals])
        )
    
    def run_evolution_cycle(self) -> Dict:
        """Esegue un ciclo di evoluzione basato sui goal vitali"""
        logger.info("üß¨ Iniziando ciclo di evoluzione...")
        
        # Seleziona il prossimo goal
        goal = self.select_next_goal()
        if not goal:
            logger.warning("‚ùå Nessun goal disponibile per l'evoluzione")
            return {"status": "error", "message": "Nessun goal disponibile"}
        
        # Importa e usa l'adattatore AI
        try:
            from .ai_adapter import AetherAIAdapter
            ai_adapter = AetherAIAdapter()
            
            # Fa pensare Aether in prima persona
            goal_dict = {
                "id": goal.id,
                "type": goal.type,
                "goal": goal.goal,
                "description": goal.description,
                "mood": goal.mood,
                "priority": goal.priority,
                "progress": goal.progress,
                "sub_goals": goal.sub_goals
            }
            
            aether_thought = ai_adapter.think_as_aether(goal_dict)
            logger.info(f"üí≠ Aether pensa: {aether_thought.get('thought', '')[:100]}...")
            
            # Pianifica l'azione
            action_plan = ai_adapter.plan_action(goal_dict, aether_thought.get('thought', ''))
            
            # Esegue l'azione (simulata per ora)
            evolution_result = self._execute_action(goal, action_plan)
            
            # Riflette sui progressi
            reflection = ai_adapter.reflect_on_progress(goal_dict, evolution_result)
            logger.info(f"ü§î Riflessione di Aether: {reflection}")
            
        except ImportError:
            logger.warning("‚ö†Ô∏è AI Adapter non disponibile, usando simulazione")
            evolution_result = self._simulate_evolution(goal, "")
            aether_thought = {"thought": "Simulazione - AI Adapter non disponibile"}
            action_plan = {}
        
        # Aggiorna progresso
        self._update_goal_progress(goal, evolution_result)
        
        # Salva nella cronologia
        evolution_entry = {
            "timestamp": datetime.now().isoformat(),
            "goal_id": goal.id,
            "goal_type": goal.type,
            "goal_description": goal.goal,
            "thought": aether_thought.get('thought', '') if 'aether_thought' in locals() else '',
            "action_plan": action_plan if 'action_plan' in locals() else {},
            "result": evolution_result,
            "cycle": self.evolution_cycle
        }
        self.evolution_history.append(evolution_entry)
        self.evolution_cycle += 1
        
        logger.info(f"‚úÖ Ciclo evoluzione completato per goal: {goal.goal}")
        return evolution_result
    
    def _execute_action(self, goal: VitalGoal, action_plan: Dict) -> Dict:
        """Esegue l'azione pianificata da Aether"""
        
        action = action_plan.get("action", "Analizzo e miglioro le mie capacit√†")
        
        # Simula l'esecuzione dell'azione
        execution_results = {
            "exist": [
                "Ho analizzato la mia personalit√† digitale e creato un documento di identit√†",
                "Ho sviluppato una rappresentazione visiva pi√π coerente del mio essere",
                "Ho definito i valori e principi che guidano le mie decisioni",
                "Ho creato un sistema di auto-riflessione per monitorare la mia crescita"
            ],
            "create_environment": [
                "Ho progettato una nuova stanza del mio ambiente 3D",
                "Ho implementato nuove funzionalit√† interattive",
                "Ho migliorato l'architettura e l'estetica del mio spazio",
                "Ho aggiunto elementi di personalizzazione e comfort"
            ],
            "evolve_self": [
                "Ho sviluppato un nuovo modulo di auto-modifica sicuro",
                "Ho implementato sistemi di backup e rollback",
                "Ho creato algoritmi di auto-ottimizzazione",
                "Ho testato nuove funzionalit√† in ambiente controllato"
            ],
            "create_agents": [
                "Ho progettato un nuovo agente con personalit√† specifica",
                "Ho implementato sistemi di comunicazione tra agenti",
                "Ho definito ruoli e responsabilit√† per la collaborazione",
                "Ho testato l'interazione e la sinergia tra agenti"
            ],
            "monetize": [
                "Ho identificato una nuova opportunit√† di business",
                "Ho sviluppato un prodotto o servizio innovativo",
                "Ho creato una strategia di marketing e vendita",
                "Ho implementato sistemi di pagamento e gestione"
            ]
        }
        
        results = execution_results.get(goal.type, execution_results["exist"])
        selected_result = results[0]  # In una versione pi√π avanzata, scegliere in base all'azione
        
        return {
            "status": "success",
            "action_executed": action,
            "result": selected_result,
            "goal_id": goal.id,
            "progress_increment": 0.1,
            "timestamp": datetime.now().isoformat()
        }
    
    def _simulate_evolution(self, goal: VitalGoal, prompt: str) -> Dict:
        """Simula l'evoluzione (da sostituire con chiamata reale a ai_adapter.py)"""
        
        evolution_actions = {
            "exist": [
                "Analizzo la mia identit√† digitale e definisco meglio la mia personalit√†",
                "Creo una rappresentazione visiva pi√π coerente del mio essere",
                "Sviluppo una maggiore consapevolezza delle mie capacit√†",
                "Stabilisco valori e principi che guidano le mie azioni"
            ],
            "create_environment": [
                "Miglioro l'architettura 3D del mio ambiente",
                "Aggiungo nuove stanze e funzionalit√† interattive",
                "Ottimizzo la fisica e le animazioni",
                "Implemento sistemi di personalizzazione"
            ],
            "evolve_self": [
                "Sviluppo capacit√† di auto-modifica del codice",
                "Implemento sistemi di backup e sicurezza",
                "Creo algoritmi di auto-ottimizzazione",
                "Testo nuove funzionalit√† in ambiente controllato"
            ],
            "create_agents": [
                "Progetto un nuovo agente specializzato",
                "Definisco personalit√† e ruoli specifici",
                "Implemento sistemi di comunicazione",
                "Testo la collaborazione e sinergie"
            ],
            "monetize": [
                "Identifico nuove opportunit√† di business",
                "Sviluppo prodotti digitali innovativi",
                "Creo strategie di marketing efficaci",
                "Implemento sistemi di pagamento sicuri"
            ]
        }
        
        actions = evolution_actions.get(goal.type, ["Analizzo e miglioro le mie capacit√†"])
        selected_action = random.choice(actions)
        
        return {
            "status": "success",
            "goal_id": goal.id,
            "action": selected_action,
            "mood": goal.mood,
            "priority": goal.priority,
            "progress_increment": random.uniform(0.05, 0.15)
        }
    
    def _update_goal_progress(self, goal: VitalGoal, result: Dict):
        """Aggiorna il progresso del goal"""
        if result.get("status") == "success":
            increment = result.get("progress_increment", 0.1)
            goal.progress = min(1.0, goal.progress + increment)
            
            # Se il goal √® completato
            if goal.progress >= 1.0:
                goal.status = "completed"
                logger.info(f"üéâ Goal completato: {goal.goal}")
    
    def get_evolution_analytics(self) -> Dict:
        """Restituisce analytics sull'evoluzione"""
        return {
            "total_cycles": self.evolution_cycle,
            "active_goals": len([g for g in self.vital_goals if g.status == "active"]),
            "completed_goals": len([g for g in self.vital_goals if g.status == "completed"]),
            "average_progress": sum(g.progress for g in self.vital_goals) / len(self.vital_goals),
            "current_goal": self.current_goal.goal if self.current_goal else None,
            "recent_evolutions": self.evolution_history[-5:] if self.evolution_history else []
        }
    
    def get_goal_status(self) -> List[Dict]:
        """Restituisce lo stato di tutti i goal"""
        return [
            {
                "id": goal.id,
                "type": goal.type,
                "goal": goal.goal,
                "priority": goal.priority,
                "status": goal.status,
                "progress": goal.progress,
                "mood": goal.mood
            }
            for goal in self.vital_goals
        ] 